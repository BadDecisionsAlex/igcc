#!/usr/bin/python

# igcc - a read-eval-print loop for C/C++ programmers
#
# Copyright (C) 2009 Andy Balaam
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

import re

import libigcc.run
import libigcc.source_code

class FakeWriteableFile:
	def __init__( self ):
		self.lines = []

	def write( self, line ):
		self.lines.append( line )

class FakeReadableFile:
	def __init__( self, lines ):
		self.lines = lines

	def readline( self ):
		if len( self.lines ) == 0:
			return None
		line = self.lines[0]
		self.lines = self.lines[1:]
		return line

def assert_strings_equal( str1, str2 ):
	if str1 == str2:
		return

	raise AssertionError( "\n" + str1 + "\n!=\n" + str2 )

def assert_strings_match( string, re_string ):
	cmp_re = re.compile( re_string, re.DOTALL )

	if cmp_re.match( string ):
		return

	raise AssertionError( "\n" + string
		+ "\ndoes not match regular expression\n" + re_string )

def run_program( commands, expected_output ):

	outputfile = FakeWriteableFile()
	stdinfile = FakeReadableFile( commands )
	libigcc.run.run( outputfile, stdinfile )

	assert_strings_equal( "".join( outputfile.lines ), expected_output )

def run_program_regex_output( commands, expected_output_re ):
	outputfile = FakeWriteableFile()
	stdinfile = FakeReadableFile( commands )
	libigcc.run.run( outputfile, stdinfile )

	assert_strings_match( "".join( outputfile.lines ), expected_output_re )

def test_declare_var():
	commands = [ "int a;" ]
	expected_output = 'g++> int a;\ng++> \n'
	run_program( commands, expected_output )

def test_declare_var_assign():
	commands = [ "int a;", "a = 10;" ]
	expected_output = 'g++> int a;\ng++> a = 10;\ng++> \n'
	run_program( commands, expected_output )

def test_declare_and_assign_var_then_print():
	commands = [ "int a = 10;",
		'printf( "%d\\n", a );' ]

	expected_output = (
'''g++> int a = 10;
g++> printf( "%d\\n", a );
10
g++> 
''' )

	run_program( commands, expected_output )


def test_print_twice():
	commands = [ "int a = 10;",
		'printf( "%d\\n", a );',
		"++a;",
		'printf( "%d\\n", a );' ]

	expected_output = (
'''g++> int a = 10;
g++> printf( "%d\\n", a );
10
g++> ++a;
g++> printf( "%d\\n", a );
11
g++> 
''' )

	run_program( commands, expected_output )

def test_compile_error():
	commands = [ "int a" ] # no semicolon

	expected_output = (
'''g++> int a
[Compile error - type .e to see it.]
g++> 
''' )

	run_program( commands, expected_output )

def test_compile_error_display():
	commands = [
		"int a", # no semicolon
		".e" ]

	# Just look for a string "xpected" in the compiler output.
	expected_output_re = (
'''g\+\+\> int a
\[Compile error - type .e to see it\.\]
g\+\+\> \.e
.*xpected.*
g\+\+\> 
$''' )

	run_program_regex_output( commands, expected_output_re )


def test_include():
	commands = [
		'#include <vector>',
		'std::vector<int> vec;',
		r'printf( "%d\n", vec.size() );' ]

	expected_output = (
r'''g++> #include <vector>
g++> std::vector<int> vec;
g++> printf( "%d\n", vec.size() );
0
g++> 
''' )

	run_program( commands, expected_output )

def test_multiple_repeated_includes():
	commands = [
		'  #  include   <vector> ',
		'std::vector<int> vec;',
		'#include <iostream>',
		' #   include   <vector>',
		'#include <iostream>',
		'using namespace std;',
		'cout << vec.size() << std::endl;' ]

	expected_output = (
r'''g++>   #  include   <vector> 
g++> std::vector<int> vec;
g++> #include <iostream>
g++>  #   include   <vector>
g++> #include <iostream>
g++> using namespace std;
g++> cout << vec.size() << std::endl;
0
g++> 
''' )

	run_program( commands, expected_output )

def test_list_program():
	commands = [
		'int a;',
		'a += 2;',
		'#include <vector>',
		'.l' ]

	expected_output = (
r'''g++> int a;
g++> a += 2;
g++> #include <vector>
g++> .l
#include <vector>

int a;
a += 2;

g++> 
''' )

	run_program( commands, expected_output )

def test_list_full_program():
	commands = [
		'int a;',
		'a += 2;',
		'#include <vector>',
		'.L' ]

	expected_output = (
'''g++> int a;
g++> a += 2;
g++> #include <vector>
g++> .L
%s
g++> 
''' % libigcc.source_code.get_full_source( 'int a;\na += 2;\n',
		"#include <vector>\n" ) )

	run_program( commands, expected_output )

def main():
	test_declare_var()
	test_declare_var_assign()
	test_declare_and_assign_var_then_print()
	test_print_twice()
	test_compile_error()
	test_compile_error_display()
	test_include()
	test_multiple_repeated_includes()

	# Should pass
	test_list_program()
	test_list_full_program()
	#test_help_message();

	# Will fail atm
	#test_quit()
	#test_undo();
	#test_edit_in_vim();
	#test_compile_warning()
	#test_remove_compile_error_message()

	print "All tests passed."


if __name__ == "__main__":
	main()


